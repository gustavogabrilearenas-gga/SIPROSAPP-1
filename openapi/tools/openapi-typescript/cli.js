#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

function usage() {
  console.error('Usage: openapi-typescript <schema> [-o <output>]');
}

function parseArgs(argv) {
  if (argv.length === 0) {
    usage();
    process.exit(1);
  }
  const args = [...argv];
  const input = args.shift();
  let output = null;
  while (args.length > 0) {
    const flag = args.shift();
    if (flag === '-o' || flag === '--output') {
      if (args.length === 0) {
        console.error('Missing value for output flag');
        process.exit(1);
      }
      output = args.shift();
    } else {
      console.error(`Unknown argument: ${flag}`);
      process.exit(1);
    }
  }
  return { input, output: output || 'types.ts' };
}

function getRefName(ref) {
  const parts = ref.split('/');
  return parts[parts.length - 1];
}

function mapPrimitive(schemaType) {
  switch (schemaType) {
    case 'string':
      return 'string';
    case 'integer':
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'null':
      return 'null';
    default:
      return 'unknown';
  }
}

function renderInlineObject(schema) {
  const props = schema.properties || {};
  const required = new Set(schema.required || []);
  const lines = Object.entries(props).map(([key, value]) => {
    const optional = required.has(key) ? '' : '?';
    return `  ${JSON.stringify(key)}${optional}: ${renderSchemaType(value)};`;
  });
  if (schema.additionalProperties) {
    lines.push(`  [key: string]: ${renderSchemaType(schema.additionalProperties)};`);
  } else if (lines.length === 0) {
    lines.push('  [key: string]: unknown;');
  }
  return `{
${lines.join('\n')}
}`;
}

function renderSchemaType(schema) {
  if (!schema || typeof schema !== 'object') {
    return 'unknown';
  }
  if (schema.$ref) {
    return getRefName(schema.$ref);
  }
  if (Array.isArray(schema.enum)) {
    return schema.enum.map((value) => JSON.stringify(value)).join(' | ');
  }
  if (Array.isArray(schema.oneOf)) {
    return schema.oneOf.map((sub) => renderSchemaType(sub)).join(' | ');
  }
  if (Array.isArray(schema.anyOf)) {
    return schema.anyOf.map((sub) => renderSchemaType(sub)).join(' | ');
  }
  if (Array.isArray(schema.allOf)) {
    return schema.allOf.map((sub) => renderSchemaType(sub)).join(' & ');
  }
  const schemaType = schema.type;
  if (schemaType === 'array') {
    const itemType = renderSchemaType(schema.items);
    return `${itemType}[]`;
  }
  if (schemaType === 'object' || schema.properties || schema.additionalProperties) {
    return renderInlineObject(schema);
  }
  if (Array.isArray(schemaType)) {
    return schemaType.map((single) => mapPrimitive(single)).join(' | ');
  }
  return mapPrimitive(schemaType);
}

function renderComponent(name, schema) {
  if (!schema || typeof schema !== 'object') {
    return `export type ${name} = unknown;`;
  }
  if (Array.isArray(schema.enum)) {
    const enumType = schema.enum.map((value) => JSON.stringify(value)).join(' | ');
    return `export type ${name} = ${enumType};`;
  }
  if (Array.isArray(schema.allOf)) {
    const composed = schema.allOf.map((sub) => renderSchemaType(sub)).join(' & ');
    return `export type ${name} = ${composed};`;
  }
  if (Array.isArray(schema.oneOf) || Array.isArray(schema.anyOf)) {
    const variants = (schema.oneOf || schema.anyOf).map((sub) => renderSchemaType(sub)).join(' | ');
    return `export type ${name} = ${variants};`;
  }
  if (schema.type === 'object' || schema.properties || schema.additionalProperties) {
    const body = renderInlineObject(schema);
    return `export interface ${name} ${body}`;
  }
  const alias = renderSchemaType(schema);
  return `export type ${name} = ${alias};`;
}

function main() {
  try {
    const { input, output } = parseArgs(process.argv.slice(2));
    const inputPath = path.resolve(process.cwd(), input);
    const outputPath = path.resolve(process.cwd(), output);
    const schemaRaw = fs.readFileSync(inputPath, 'utf8');
    const openapi = JSON.parse(schemaRaw);
    const lines = [];
    lines.push('// Generated by local openapi-typescript stub.');
    lines.push('// This file captures a subset of the OpenAPI contract for TypeScript usage.');
    lines.push('');
    const components = (openapi.components && openapi.components.schemas) || {};
    const componentEntries = Object.entries(components);
    if (componentEntries.length === 0) {
      lines.push('export interface Schemas {');
      lines.push('  [key: string]: unknown;');
      lines.push('}');
    } else {
      componentEntries.forEach(([name, schema]) => {
        lines.push(renderComponent(name, schema));
        lines.push('');
      });
      lines.push('export interface Schemas {');
      componentEntries.forEach(([name]) => {
        lines.push(`  ${name}: ${name};`);
      });
      lines.push('}');
    }
    lines.push('');
    lines.push('export type Paths = Record<string, Record<string, unknown>>;');
    const content = lines.join('\n');
    const dir = path.dirname(outputPath);
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(outputPath, content + '\n', 'utf8');
    process.exit(0);
  } catch (error) {
    console.error('[openapi-typescript stub]', error.message);
    process.exit(1);
  }
}

main();
